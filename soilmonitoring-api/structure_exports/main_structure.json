{
  "project_info": {
    "name": "main",
    "path": "D:\\SoilMonitoringSystem\\soilmonitoring-api\\src\\main",
    "generated_at": "2025-11-11T20:46:11.6487272",
    "total_files": 29,
    "total_size": 71921
  },
  "structure": {
    "java": {
      "me": {
        "soilmonitoring": {
          "api": {
            "ApiApplication.java": {
              "type": "file",
              "info": {
                "size": 881,
                "last_modified": "2025-11-11T20:46:11.5633705",
                "mime_type": "text/x-java-source",
                "extension": ".java"
              }
            },
            "boundaries": {
              "AlertResource.java": {
                "type": "file",
                "info": {
                  "size": 4465,
                  "last_modified": "2025-11-11T20:46:11.5658858",
                  "mime_type": "text/x-java-source",
                  "extension": ".java"
                }
              },
              "FieldResource.java": {
                "type": "file",
                "info": {
                  "size": 4120,
                  "last_modified": "2025-11-11T20:46:11.569282",
                  "mime_type": "text/x-java-source",
                  "extension": ".java"
                }
              },
              "PredictionResource.java": {
                "type": "file",
                "info": {
                  "size": 4454,
                  "last_modified": "2025-11-11T20:46:11.5718589",
                  "mime_type": "text/x-java-source",
                  "extension": ".java"
                }
              },
              "ReadingResource.java": {
                "type": "file",
                "info": {
                  "size": 4588,
                  "last_modified": "2025-11-11T20:46:11.5763168",
                  "mime_type": "text/x-java-source",
                  "extension": ".java"
                }
              },
              "SensorResource.java": {
                "type": "file",
                "info": {
                  "size": 5140,
                  "last_modified": "2025-11-11T20:46:11.578885",
                  "mime_type": "text/x-java-source",
                  "extension": ".java"
                }
              },
              "TestResource.java": {
                "type": "file",
                "info": {
                  "size": 716,
                  "last_modified": "2025-11-11T20:46:11.5809987",
                  "mime_type": "text/x-java-source",
                  "extension": ".java"
                }
              }
            },
            "controllers": {
              "managers": {
                "SoilMonitoringManager.java": {
                  "type": "file",
                  "info": {
                    "size": 4696,
                    "last_modified": "2025-11-11T20:46:11.5843399",
                    "mime_type": "text/x-java-source",
                    "extension": ".java"
                  }
                }
              },
              "repositories": {
                "AlertRepository.java": {
                  "type": "file",
                  "info": {
                    "size": 1693,
                    "last_modified": "2025-11-11T20:46:11.5878513",
                    "mime_type": "text/x-java-source",
                    "extension": ".java"
                  }
                },
                "FieldRepository.java": {
                  "type": "file",
                  "info": {
                    "size": 598,
                    "last_modified": "2025-11-11T20:46:11.5908517",
                    "mime_type": "text/x-java-source",
                    "extension": ".java"
                  }
                },
                "PredictionRepository.java": {
                  "type": "file",
                  "info": {
                    "size": 2806,
                    "last_modified": "2025-11-11T20:46:11.5928519",
                    "mime_type": "text/x-java-source",
                    "extension": ".java"
                  }
                },
                "SensorReadingRepository.java": {
                  "type": "file",
                  "info": {
                    "size": 2191,
                    "last_modified": "2025-11-11T20:46:11.5959235",
                    "mime_type": "text/x-java-source",
                    "extension": ".java"
                  }
                },
                "SensorRepository.java": {
                  "type": "file",
                  "info": {
                    "size": 1986,
                    "last_modified": "2025-11-11T20:46:11.5979296",
                    "mime_type": "text/x-java-source",
                    "extension": ".java"
                  }
                },
                "TreatmentRepository.java": {
                  "type": "file",
                  "info": {
                    "size": 1649,
                    "last_modified": "2025-11-11T20:46:11.5999292",
                    "mime_type": "text/x-java-source",
                    "extension": ".java"
                  }
                },
                "UserRepository.java": {
                  "type": "file",
                  "info": {
                    "size": 1312,
                    "last_modified": "2025-11-11T20:46:11.6029309",
                    "mime_type": "text/x-java-source",
                    "extension": ".java"
                  }
                }
              }
            },
            "entities": {
              "Alert.java": {
                "type": "file",
                "info": {
                  "size": 2298,
                  "last_modified": "2025-11-11T20:46:11.6070789",
                  "mime_type": "text/x-java-source",
                  "extension": ".java"
                }
              },
              "Field.java": {
                "type": "file",
                "info": {
                  "size": 2225,
                  "last_modified": "2025-11-11T20:46:11.6101969",
                  "mime_type": "text/x-java-source",
                  "extension": ".java"
                }
              },
              "Location.java": {
                "type": "file",
                "info": {
                  "size": 1023,
                  "last_modified": "2025-11-11T20:46:11.6122028",
                  "mime_type": "text/x-java-source",
                  "extension": ".java"
                }
              },
              "Prediction.java": {
                "type": "file",
                "info": {
                  "size": 5102,
                  "last_modified": "2025-11-11T20:46:11.6147079",
                  "mime_type": "text/x-java-source",
                  "extension": ".java"
                }
              },
              "RootEntity.java": {
                "type": "file",
                "info": {
                  "size": 290,
                  "last_modified": "2025-11-11T20:46:11.6167138",
                  "mime_type": "text/x-java-source",
                  "extension": ".java"
                }
              },
              "Sensor.java": {
                "type": "file",
                "info": {
                  "size": 2191,
                  "last_modified": "2025-11-11T20:46:11.6187175",
                  "mime_type": "text/x-java-source",
                  "extension": ".java"
                }
              },
              "SensorData.java": {
                "type": "file",
                "info": {
                  "size": 1908,
                  "last_modified": "2025-11-11T20:46:11.6207195",
                  "mime_type": "text/x-java-source",
                  "extension": ".java"
                }
              },
              "SensorReading.java": {
                "type": "file",
                "info": {
                  "size": 1614,
                  "last_modified": "2025-11-11T20:46:11.622744",
                  "mime_type": "text/x-java-source",
                  "extension": ".java"
                }
              },
              "Treatment.java": {
                "type": "file",
                "info": {
                  "size": 2340,
                  "last_modified": "2025-11-11T20:46:11.6252212",
                  "mime_type": "text/x-java-source",
                  "extension": ".java"
                }
              },
              "User.java": {
                "type": "file",
                "info": {
                  "size": 1807,
                  "last_modified": "2025-11-11T20:46:11.6272533",
                  "mime_type": "text/x-java-source",
                  "extension": ".java"
                }
              }
            },
            "mqtt": {
              "MQTTService.java": {
                "type": "file",
                "info": {
                  "size": 8692,
                  "last_modified": "2025-11-11T20:46:11.6302317",
                  "mime_type": "text/x-java-source",
                  "extension": ".java"
                }
              }
            },
            "security": {
            },
            "websocket": {
            }
          }
        }
      }
    },
    "resources": {
      "META-INF": {
        "microprofile-config.properties": {
          "type": "file",
          "info": {
            "size": 614,
            "last_modified": "2025-11-11T20:46:11.6377409",
            "mime_type": "text/x-java-properties",
            "extension": ".properties"
          }
        }
      }
    },
    "webapp": {
      "WEB-INF": {
        "beans.xml": {
          "type": "file",
          "info": {
            "size": 314,
            "last_modified": "2025-11-11T20:46:11.6422624",
            "mime_type": "application/xml",
            "extension": ".xml"
          }
        },
        "jboss-web.xml": {
          "type": "file",
          "info": {
            "size": 208,
            "last_modified": "2025-11-11T20:46:11.6447172",
            "mime_type": "application/xml",
            "extension": ".xml"
          }
        }
      }
    }
  },
  "files": [
    {
      "path": "java\\me\\soilmonitoring\\api\\ApiApplication.java",
      "content": "package me.soilmonitoring.api;\r\n\r\nimport jakarta.enterprise.context.ApplicationScoped;\r\nimport jakarta.enterprise.context.Dependent;\r\nimport jakarta.enterprise.inject.Disposes;\r\nimport jakarta.enterprise.inject.Produces;\r\nimport jakarta.enterprise.inject.spi.InjectionPoint;\r\nimport jakarta.ws.rs.ApplicationPath;\r\nimport jakarta.ws.rs.core.Application;\r\n\r\nimport java.util.logging.Logger;\r\n\r\n@ApplicationPath(\"/api\")\r\npublic class ApiApplication extends Application {\r\n\r\n    @ApplicationScoped\r\n    public static final class CDIConfigurator {\r\n\r\n        @Produces\r\n        @Dependent\r\n        public Logger getLogger(InjectionPoint injectionPoint) {\r\n            return Logger.getLogger(injectionPoint.getBean().getBeanClass().getName());\r\n        }\r\n\r\n        public void disposeLogger(@Disposes Logger logger) {\r\n            logger.info(\"logger disposed!\");\r\n        }\r\n    }\r\n}",
      "info": {
        "size": 881,
        "last_modified": "2025-11-11T20:46:11.5633705",
        "mime_type": "text/x-java-source",
        "extension": ".java"
      }
    },
    {
      "path": "java\\me\\soilmonitoring\\api\\boundaries\\AlertResource.java",
      "content": "package me.soilmonitoring.api.boundaries;\r\n\r\nimport jakarta.enterprise.context.RequestScoped;\r\nimport jakarta.inject.Inject;\r\nimport jakarta.ws.rs.*;\r\nimport jakarta.ws.rs.core.MediaType;\r\nimport jakarta.ws.rs.core.Response;\r\nimport me.soilmonitoring.api.controllers.managers.SoilMonitoringManager;\r\nimport me.soilmonitoring.api.controllers.repositories.AlertRepository;\r\nimport me.soilmonitoring.api.entities.Alert;\r\n\r\nimport java.time.LocalDateTime;\r\nimport java.util.List;\r\nimport java.util.UUID;\r\nimport java.util.logging.Logger;\r\n\r\n@Path(\"/alerts\")\r\n@RequestScoped\r\n@Produces(MediaType.APPLICATION_JSON)\r\n@Consumes(MediaType.APPLICATION_JSON)\r\npublic class AlertResource {\r\n\r\n    @Inject\r\n    private Logger logger;\r\n\r\n    @Inject\r\n    private SoilMonitoringManager manager;\r\n\r\n    @Inject\r\n    private AlertRepository alertRepository;\r\n\r\n    @GET\r\n    @Path(\"/user/{userId}\")\r\n    public Response getUserAlerts(@PathParam(\"userId\") String userId,\r\n                                  @QueryParam(\"unread\") Boolean unreadOnly) {\r\n        try {\r\n            List<Alert> alerts;\r\n            if (unreadOnly != null && unreadOnly) {\r\n                alerts = manager.getUnreadAlerts(userId);\r\n            } else {\r\n                alerts = alertRepository.findByUserId(userId);\r\n            }\r\n            return Response.ok(alerts).build();\r\n        } catch (Exception e) {\r\n            logger.severe(\"Error getting user alerts: \" + e.getMessage());\r\n            return Response.status(Response.Status.INTERNAL_SERVER_ERROR)\r\n                    .entity(\"Error retrieving alerts\").build();\r\n        }\r\n    }\r\n\r\n    @GET\r\n    @Path(\"/{alertId}\")\r\n    public Response getAlertById(@PathParam(\"alertId\") String alertId) {\r\n        try {\r\n            Alert alert = alertRepository.findById(alertId)\r\n                    .orElseThrow(IllegalArgumentException::new);\r\n            return Response.ok(alert).build();\r\n        } catch (IllegalArgumentException e) {\r\n            return Response.status(Response.Status.NOT_FOUND)\r\n                    .entity(\"Alert not found\").build();\r\n        } catch (Exception e) {\r\n            logger.severe(\"Error getting alert: \" + e.getMessage());\r\n            return Response.status(Response.Status.INTERNAL_SERVER_ERROR)\r\n                    .entity(\"Error retrieving alert\").build();\r\n        }\r\n    }\r\n\r\n    @POST\r\n    public Response createAlert(Alert alert) {\r\n        try {\r\n            alert.setId(UUID.randomUUID().toString());\r\n            alert.setCreatedAt(LocalDateTime.now());\r\n            alert.setIsRead(false);\r\n            Alert savedAlert = alertRepository.save(alert);\r\n            logger.info(\"Alert created: \" + savedAlert.getId());\r\n            return Response.status(Response.Status.CREATED).entity(savedAlert).build();\r\n        } catch (Exception e) {\r\n            logger.severe(\"Error creating alert: \" + e.getMessage());\r\n            return Response.status(Response.Status.INTERNAL_SERVER_ERROR)\r\n                    .entity(\"Error creating alert\").build();\r\n        }\r\n    }\r\n\r\n    @PUT\r\n    @Path(\"/{alertId}/read\")\r\n    public Response markAlertAsRead(@PathParam(\"alertId\") String alertId) {\r\n        try {\r\n            Alert alert = alertRepository.findById(alertId)\r\n                    .orElseThrow(IllegalArgumentException::new);\r\n            alert.setIsRead(true);\r\n            alertRepository.save(alert);\r\n            logger.info(\"Alert marked as read: \" + alertId);\r\n            return Response.ok(alert).build();\r\n        } catch (IllegalArgumentException e) {\r\n            return Response.status(Response.Status.NOT_FOUND)\r\n                    .entity(\"Alert not found\").build();\r\n        } catch (Exception e) {\r\n            logger.severe(\"Error marking alert as read: \" + e.getMessage());\r\n            return Response.status(Response.Status.INTERNAL_SERVER_ERROR)\r\n                    .entity(\"Error updating alert\").build();\r\n        }\r\n    }\r\n\r\n    @DELETE\r\n    @Path(\"/{alertId}\")\r\n    public Response deleteAlert(@PathParam(\"alertId\") String alertId) {\r\n        try {\r\n            alertRepository.deleteById(alertId);\r\n            logger.info(\"Alert deleted: \" + alertId);\r\n            return Response.noContent().build();\r\n        } catch (Exception e) {\r\n            logger.severe(\"Error deleting alert: \" + e.getMessage());\r\n            return Response.status(Response.Status.INTERNAL_SERVER_ERROR)\r\n                    .entity(\"Error deleting alert\").build();\r\n        }\r\n    }\r\n}\r\n",
      "info": {
        "size": 4465,
        "last_modified": "2025-11-11T20:46:11.5658858",
        "mime_type": "text/x-java-source",
        "extension": ".java"
      }
    },
    {
      "path": "java\\me\\soilmonitoring\\api\\boundaries\\FieldResource.java",
      "content": "package me.soilmonitoring.api.boundaries;\r\n\r\nimport jakarta.enterprise.context.RequestScoped;\r\nimport jakarta.inject.Inject;\r\nimport jakarta.ws.rs.*;\r\nimport jakarta.ws.rs.core.MediaType;\r\nimport jakarta.ws.rs.core.Response;\r\nimport me.soilmonitoring.api.controllers.managers.SoilMonitoringManager;\r\nimport me.soilmonitoring.api.controllers.repositories.FieldRepository;\r\nimport me.soilmonitoring.api.entities.Field;\r\n\r\nimport java.time.LocalDateTime;\r\nimport java.util.List;\r\nimport java.util.UUID;\r\nimport java.util.logging.Logger;\r\n\r\n@Path(\"/fields\")\r\n@RequestScoped\r\n@Produces(MediaType.APPLICATION_JSON)\r\n@Consumes(MediaType.APPLICATION_JSON)\r\npublic class FieldResource {\r\n\r\n    @Inject\r\n    private Logger logger;\r\n\r\n    @Inject\r\n    private SoilMonitoringManager manager;\r\n\r\n    @Inject\r\n    private FieldRepository fieldRepository;\r\n\r\n    @GET\r\n    @Path(\"/user/{userId}\")\r\n    public Response getUserFields(@PathParam(\"userId\") String userId) {\r\n        try {\r\n            List<Field> fields = manager.getUserFields(userId);\r\n            return Response.ok(fields).build();\r\n        } catch (Exception e) {\r\n            logger.severe(\"Error getting user fields: \" + e.getMessage());\r\n            return Response.status(Response.Status.INTERNAL_SERVER_ERROR)\r\n                    .entity(\"Error retrieving fields\").build();\r\n        }\r\n    }\r\n\r\n    @GET\r\n    @Path(\"/{fieldId}\")\r\n    public Response getFieldById(@PathParam(\"fieldId\") String fieldId) {\r\n        try {\r\n            Field field = manager.findFieldById(fieldId);\r\n            return Response.ok(field).build();\r\n        } catch (IllegalArgumentException e) {\r\n            return Response.status(Response.Status.NOT_FOUND)\r\n                    .entity(\"Field not found\").build();\r\n        } catch (Exception e) {\r\n            logger.severe(\"Error getting field: \" + e.getMessage());\r\n            return Response.status(Response.Status.INTERNAL_SERVER_ERROR)\r\n                    .entity(\"Error retrieving field\").build();\r\n        }\r\n    }\r\n\r\n    @POST\r\n    public Response createField(Field field) {\r\n        try {\r\n            field.setId(UUID.randomUUID().toString());\r\n            field.setCreatedAt(LocalDateTime.now());\r\n            Field savedField = fieldRepository.save(field);\r\n            logger.info(\"Field created: \" + savedField.getId());\r\n            return Response.status(Response.Status.CREATED).entity(savedField).build();\r\n        } catch (Exception e) {\r\n            logger.severe(\"Error creating field: \" + e.getMessage());\r\n            return Response.status(Response.Status.INTERNAL_SERVER_ERROR)\r\n                    .entity(\"Error creating field\").build();\r\n        }\r\n    }\r\n\r\n    @PUT\r\n    @Path(\"/{fieldId}\")\r\n    public Response updateField(@PathParam(\"fieldId\") String fieldId, Field field) {\r\n        try {\r\n            Field existingField = manager.findFieldById(fieldId);\r\n            field.setId(fieldId);\r\n            field.setCreatedAt(existingField.getCreatedAt());\r\n            Field updatedField = fieldRepository.save(field);\r\n            logger.info(\"Field updated: \" + fieldId);\r\n            return Response.ok(updatedField).build();\r\n        } catch (IllegalArgumentException e) {\r\n            return Response.status(Response.Status.NOT_FOUND)\r\n                    .entity(\"Field not found\").build();\r\n        } catch (Exception e) {\r\n            logger.severe(\"Error updating field: \" + e.getMessage());\r\n            return Response.status(Response.Status.INTERNAL_SERVER_ERROR)\r\n                    .entity(\"Error updating field\").build();\r\n        }\r\n    }\r\n\r\n    @DELETE\r\n    @Path(\"/{fieldId}\")\r\n    public Response deleteField(@PathParam(\"fieldId\") String fieldId) {\r\n        try {\r\n            fieldRepository.deleteById(fieldId);\r\n            logger.info(\"Field deleted: \" + fieldId);\r\n            return Response.noContent().build();\r\n        } catch (Exception e) {\r\n            logger.severe(\"Error deleting field: \" + e.getMessage());\r\n            return Response.status(Response.Status.INTERNAL_SERVER_ERROR)\r\n                    .entity(\"Error deleting field\").build();\r\n        }\r\n    }\r\n}",
      "info": {
        "size": 4120,
        "last_modified": "2025-11-11T20:46:11.569282",
        "mime_type": "text/x-java-source",
        "extension": ".java"
      }
    },
    {
      "path": "java\\me\\soilmonitoring\\api\\boundaries\\PredictionResource.java",
      "content": "package me.soilmonitoring.api.boundaries;\r\n\r\nimport jakarta.enterprise.context.RequestScoped;\r\nimport jakarta.inject.Inject;\r\nimport jakarta.ws.rs.*;\r\nimport jakarta.ws.rs.core.MediaType;\r\nimport jakarta.ws.rs.core.Response;\r\nimport me.soilmonitoring.api.controllers.managers.SoilMonitoringManager;\r\nimport me.soilmonitoring.api.controllers.repositories.PredictionRepository;\r\nimport me.soilmonitoring.api.entities.Prediction;\r\n\r\nimport java.time.LocalDateTime;\r\nimport java.util.List;\r\nimport java.util.UUID;\r\nimport java.util.logging.Logger;\r\n\r\n@Path(\"/predictions\")\r\n@RequestScoped\r\n@Produces(MediaType.APPLICATION_JSON)\r\n@Consumes(MediaType.APPLICATION_JSON)\r\npublic class PredictionResource {\r\n\r\n    @Inject\r\n    private Logger logger;\r\n\r\n    @Inject\r\n    private SoilMonitoringManager manager;\r\n\r\n    @Inject\r\n    private PredictionRepository predictionRepository;\r\n\r\n    @GET\r\n    @Path(\"/field/{fieldId}\")\r\n    public Response getFieldPredictions(@PathParam(\"fieldId\") String fieldId,\r\n                                        @QueryParam(\"type\") String predictionType) {\r\n        try {\r\n            List<Prediction> predictions;\r\n            if (predictionType != null && !predictionType.isEmpty()) {\r\n                predictions = manager.getFieldPredictions(fieldId, predictionType);\r\n            } else {\r\n                predictions = predictionRepository.findByFieldId(fieldId);\r\n            }\r\n            return Response.ok(predictions).build();\r\n        } catch (Exception e) {\r\n            logger.severe(\"Error getting field predictions: \" + e.getMessage());\r\n            return Response.status(Response.Status.INTERNAL_SERVER_ERROR)\r\n                    .entity(\"Error retrieving predictions\").build();\r\n        }\r\n    }\r\n\r\n    @GET\r\n    @Path(\"/{predictionId}\")\r\n    public Response getPredictionById(@PathParam(\"predictionId\") String predictionId) {\r\n        try {\r\n            Prediction prediction = predictionRepository.findById(predictionId)\r\n                    .orElseThrow(IllegalArgumentException::new);\r\n            return Response.ok(prediction).build();\r\n        } catch (IllegalArgumentException e) {\r\n            return Response.status(Response.Status.NOT_FOUND)\r\n                    .entity(\"Prediction not found\").build();\r\n        } catch (Exception e) {\r\n            logger.severe(\"Error getting prediction: \" + e.getMessage());\r\n            return Response.status(Response.Status.INTERNAL_SERVER_ERROR)\r\n                    .entity(\"Error retrieving prediction\").build();\r\n        }\r\n    }\r\n\r\n    @POST\r\n    @Path(\"/crop\")\r\n    public Response createCropPrediction(Prediction prediction) {\r\n        try {\r\n            prediction.setId(UUID.randomUUID().toString());\r\n            prediction.setPredictionType(\"crop\");\r\n            prediction.setModelUsed(\"CatBoost\");\r\n            prediction.setCreatedAt(LocalDateTime.now());\r\n\r\n            // TODO: Call ML model here and set prediction.setResult(...)\r\n\r\n            Prediction savedPrediction = predictionRepository.save(prediction);\r\n            logger.info(\"Crop prediction created: \" + savedPrediction.getId());\r\n            return Response.status(Response.Status.CREATED).entity(savedPrediction).build();\r\n        } catch (Exception e) {\r\n            logger.severe(\"Error creating crop prediction: \" + e.getMessage());\r\n            return Response.status(Response.Status.INTERNAL_SERVER_ERROR)\r\n                    .entity(\"Error creating prediction\").build();\r\n        }\r\n    }\r\n\r\n    @POST\r\n    @Path(\"/fertilizer\")\r\n    public Response createFertilizerPrediction(Prediction prediction) {\r\n        try {\r\n            prediction.setId(UUID.randomUUID().toString());\r\n            prediction.setPredictionType(\"fertilizer\");\r\n            prediction.setModelUsed(\"RandomForest\");\r\n            prediction.setCreatedAt(LocalDateTime.now());\r\n\r\n            // TODO: Call ML model here and set prediction.setResult(...)\r\n\r\n            Prediction savedPrediction = predictionRepository.save(prediction);\r\n            logger.info(\"Fertilizer prediction created: \" + savedPrediction.getId());\r\n            return Response.status(Response.Status.CREATED).entity(savedPrediction).build();\r\n        } catch (Exception e) {\r\n            logger.severe(\"Error creating fertilizer prediction: \" + e.getMessage());\r\n            return Response.status(Response.Status.INTERNAL_SERVER_ERROR)\r\n                    .entity(\"Error creating prediction\").build();\r\n        }\r\n    }\r\n}",
      "info": {
        "size": 4454,
        "last_modified": "2025-11-11T20:46:11.5718589",
        "mime_type": "text/x-java-source",
        "extension": ".java"
      }
    },
    {
      "path": "java\\me\\soilmonitoring\\api\\boundaries\\ReadingResource.java",
      "content": "package me.soilmonitoring.api.boundaries;\r\n\r\nimport jakarta.enterprise.context.RequestScoped;\r\nimport jakarta.inject.Inject;\r\nimport jakarta.ws.rs.*;\r\nimport jakarta.ws.rs.core.MediaType;\r\nimport jakarta.ws.rs.core.Response;\r\nimport me.soilmonitoring.api.controllers.managers.SoilMonitoringManager;\r\nimport me.soilmonitoring.api.controllers.repositories.SensorReadingRepository;\r\nimport me.soilmonitoring.api.controllers.repositories.SensorReadingRepository;\r\nimport me.soilmonitoring.api.entities.SensorReading;\r\n\r\nimport java.time.LocalDateTime;\r\nimport java.util.List;\r\nimport java.util.UUID;\r\nimport java.util.logging.Logger;\r\n\r\n@Path(\"/readings\")\r\n@RequestScoped\r\n@Produces(MediaType.APPLICATION_JSON)\r\n@Consumes(MediaType.APPLICATION_JSON)\r\npublic class ReadingResource {\r\n\r\n    @Inject\r\n    private Logger logger;\r\n\r\n    @Inject\r\n    private SoilMonitoringManager manager;\r\n\r\n    @Inject\r\n    private SensorReadingRepository readingRepository;\r\n\r\n    @GET\r\n    @Path(\"/field/{fieldId}\")\r\n    public Response getFieldReadings(@PathParam(\"fieldId\") String fieldId) {\r\n        try {\r\n            List<SensorReading> readings = manager.getFieldReadings(fieldId);\r\n            return Response.ok(readings).build();\r\n        } catch (Exception e) {\r\n            logger.severe(\"Error getting field readings: \" + e.getMessage());\r\n            return Response.status(Response.Status.INTERNAL_SERVER_ERROR)\r\n                    .entity(\"Error retrieving readings\").build();\r\n        }\r\n    }\r\n\r\n    @GET\r\n    @Path(\"/field/{fieldId}/range\")\r\n    public Response getFieldReadingsByTimeRange(\r\n            @PathParam(\"fieldId\") String fieldId,\r\n            @QueryParam(\"from\") String from,\r\n            @QueryParam(\"to\") String to) {\r\n        try {\r\n            LocalDateTime fromDate = LocalDateTime.parse(from);\r\n            LocalDateTime toDate = LocalDateTime.parse(to);\r\n            List<SensorReading> readings = manager.getFieldReadingsByTimeRange(fieldId, fromDate, toDate);\r\n            return Response.ok(readings).build();\r\n        } catch (Exception e) {\r\n            logger.severe(\"Error getting field readings by time range: \" + e.getMessage());\r\n            return Response.status(Response.Status.INTERNAL_SERVER_ERROR)\r\n                    .entity(\"Error retrieving readings\").build();\r\n        }\r\n    }\r\n\r\n    @GET\r\n    @Path(\"/{readingId}\")\r\n    public Response getReadingById(@PathParam(\"readingId\") String readingId) {\r\n        try {\r\n            SensorReading reading = readingRepository.findById(readingId)\r\n                    .orElseThrow(IllegalArgumentException::new);\r\n            return Response.ok(reading).build();\r\n        } catch (IllegalArgumentException e) {\r\n            return Response.status(Response.Status.NOT_FOUND)\r\n                    .entity(\"Reading not found\").build();\r\n        } catch (Exception e) {\r\n            logger.severe(\"Error getting reading: \" + e.getMessage());\r\n            return Response.status(Response.Status.INTERNAL_SERVER_ERROR)\r\n                    .entity(\"Error retrieving reading\").build();\r\n        }\r\n    }\r\n\r\n    @POST\r\n    public Response createReading(SensorReading reading) {\r\n        try {\r\n            reading.setId(UUID.randomUUID().toString());\r\n            reading.setTimestamp(LocalDateTime.now());\r\n            SensorReading savedReading = readingRepository.save(reading);\r\n            logger.info(\"Sensor reading created: \" + savedReading.getId());\r\n            return Response.status(Response.Status.CREATED).entity(savedReading).build();\r\n        } catch (Exception e) {\r\n            logger.severe(\"Error creating reading: \" + e.getMessage());\r\n            return Response.status(Response.Status.INTERNAL_SERVER_ERROR)\r\n                    .entity(\"Error creating reading\").build();\r\n        }\r\n    }\r\n\r\n    @GET\r\n    @Path(\"/field/{fieldId}/latest\")\r\n    public Response getLatestReading(@PathParam(\"fieldId\") String fieldId) {\r\n        try {\r\n            List<SensorReading> readings = manager.getFieldReadings(fieldId);\r\n            if (readings.isEmpty()) {\r\n                return Response.status(Response.Status.NOT_FOUND)\r\n                        .entity(\"No readings found\").build();\r\n            }\r\n            SensorReading latest = readings.get(readings.size() - 1);\r\n            return Response.ok(latest).build();\r\n        } catch (Exception e) {\r\n            logger.severe(\"Error getting latest reading: \" + e.getMessage());\r\n            return Response.status(Response.Status.INTERNAL_SERVER_ERROR)\r\n                    .entity(\"Error retrieving latest reading\").build();\r\n        }\r\n    }\r\n}",
      "info": {
        "size": 4588,
        "last_modified": "2025-11-11T20:46:11.5763168",
        "mime_type": "text/x-java-source",
        "extension": ".java"
      }
    },
    {
      "path": "java\\me\\soilmonitoring\\api\\boundaries\\SensorResource.java",
      "content": "package me.soilmonitoring.api.boundaries;\r\n\r\nimport jakarta.enterprise.context.RequestScoped;\r\nimport jakarta.inject.Inject;\r\nimport jakarta.ws.rs.*;\r\nimport jakarta.ws.rs.core.MediaType;\r\nimport jakarta.ws.rs.core.Response;\r\nimport me.soilmonitoring.api.controllers.managers.SoilMonitoringManager;\r\nimport me.soilmonitoring.api.controllers.repositories.SensorRepository;\r\nimport me.soilmonitoring.api.entities.Sensor;\r\n\r\nimport java.time.LocalDateTime;\r\nimport java.util.List;\r\nimport java.util.UUID;\r\nimport java.util.logging.Logger;\r\n\r\n@Path(\"/sensors\")\r\n@RequestScoped\r\n@Produces(MediaType.APPLICATION_JSON)\r\n@Consumes(MediaType.APPLICATION_JSON)\r\npublic class SensorResource {\r\n\r\n    @Inject\r\n    private Logger logger;\r\n\r\n    @Inject\r\n    private SoilMonitoringManager manager;\r\n\r\n    @Inject\r\n    private SensorRepository sensorRepository;\r\n\r\n    @GET\r\n    @Path(\"/field/{fieldId}\")\r\n    public Response getFieldSensors(@PathParam(\"fieldId\") String fieldId) {\r\n        try {\r\n            List<Sensor> sensors = manager.getFieldSensors(fieldId);\r\n            return Response.ok(sensors).build();\r\n        } catch (Exception e) {\r\n            logger.severe(\"Error getting field sensors: \" + e.getMessage());\r\n            return Response.status(Response.Status.INTERNAL_SERVER_ERROR)\r\n                    .entity(\"Error retrieving sensors\").build();\r\n        }\r\n    }\r\n\r\n    @GET\r\n    @Path(\"/{sensorId}\")\r\n    public Response getSensorById(@PathParam(\"sensorId\") String sensorId) {\r\n        try {\r\n            Sensor sensor = sensorRepository.findById(sensorId)\r\n                    .orElseThrow(IllegalArgumentException::new);\r\n            return Response.ok(sensor).build();\r\n        } catch (IllegalArgumentException e) {\r\n            return Response.status(Response.Status.NOT_FOUND)\r\n                    .entity(\"Sensor not found\").build();\r\n        } catch (Exception e) {\r\n            logger.severe(\"Error getting sensor: \" + e.getMessage());\r\n            return Response.status(Response.Status.INTERNAL_SERVER_ERROR)\r\n                    .entity(\"Error retrieving sensor\").build();\r\n        }\r\n    }\r\n\r\n    @GET\r\n    @Path(\"/device/{deviceId}\")\r\n    public Response getSensorByDeviceId(@PathParam(\"deviceId\") String deviceId) {\r\n        try {\r\n            Sensor sensor = manager.findSensorByDeviceId(deviceId);\r\n            return Response.ok(sensor).build();\r\n        } catch (IllegalArgumentException e) {\r\n            return Response.status(Response.Status.NOT_FOUND)\r\n                    .entity(\"Sensor not found\").build();\r\n        } catch (Exception e) {\r\n            logger.severe(\"Error getting sensor by device ID: \" + e.getMessage());\r\n            return Response.status(Response.Status.INTERNAL_SERVER_ERROR)\r\n                    .entity(\"Error retrieving sensor\").build();\r\n        }\r\n    }\r\n\r\n    @POST\r\n    public Response createSensor(Sensor sensor) {\r\n        try {\r\n            sensor.setId(UUID.randomUUID().toString());\r\n            sensor.setInstalledAt(LocalDateTime.now());\r\n            sensor.setStatus(\"active\");\r\n            Sensor savedSensor = sensorRepository.save(sensor);\r\n            logger.info(\"Sensor created: \" + savedSensor.getId());\r\n            return Response.status(Response.Status.CREATED).entity(savedSensor).build();\r\n        } catch (Exception e) {\r\n            logger.severe(\"Error creating sensor: \" + e.getMessage());\r\n            return Response.status(Response.Status.INTERNAL_SERVER_ERROR)\r\n                    .entity(\"Error creating sensor\").build();\r\n        }\r\n    }\r\n\r\n    @PUT\r\n    @Path(\"/{sensorId}/status\")\r\n    public Response updateSensorStatus(@PathParam(\"sensorId\") String sensorId,\r\n                                       @QueryParam(\"status\") String status) {\r\n        try {\r\n            Sensor sensor = sensorRepository.findById(sensorId)\r\n                    .orElseThrow(IllegalArgumentException::new);\r\n            sensor.setStatus(status);\r\n            sensor.setLastConnection(LocalDateTime.now());\r\n            sensorRepository.save(sensor);\r\n            logger.info(\"Sensor status updated: \" + sensorId);\r\n            return Response.ok(sensor).build();\r\n        } catch (IllegalArgumentException e) {\r\n            return Response.status(Response.Status.NOT_FOUND)\r\n                    .entity(\"Sensor not found\").build();\r\n        } catch (Exception e) {\r\n            logger.severe(\"Error updating sensor status: \" + e.getMessage());\r\n            return Response.status(Response.Status.INTERNAL_SERVER_ERROR)\r\n                    .entity(\"Error updating sensor status\").build();\r\n        }\r\n    }\r\n\r\n    @DELETE\r\n    @Path(\"/{sensorId}\")\r\n    public Response deleteSensor(@PathParam(\"sensorId\") String sensorId) {\r\n        try {\r\n            sensorRepository.deleteById(sensorId);\r\n            logger.info(\"Sensor deleted: \" + sensorId);\r\n            return Response.noContent().build();\r\n        } catch (Exception e) {\r\n            logger.severe(\"Error deleting sensor: \" + e.getMessage());\r\n            return Response.status(Response.Status.INTERNAL_SERVER_ERROR)\r\n                    .entity(\"Error deleting sensor\").build();\r\n        }\r\n    }\r\n}",
      "info": {
        "size": 5140,
        "last_modified": "2025-11-11T20:46:11.578885",
        "mime_type": "text/x-java-source",
        "extension": ".java"
      }
    },
    {
      "path": "java\\me\\soilmonitoring\\api\\boundaries\\TestResource.java",
      "content": "package me.soilmonitoring.api.boundaries;\r\n\r\nimport jakarta.enterprise.context.RequestScoped;\r\nimport jakarta.ws.rs.GET;\r\nimport jakarta.ws.rs.Path;\r\nimport jakarta.ws.rs.Produces;\r\nimport jakarta.ws.rs.core.MediaType;\r\nimport jakarta.ws.rs.core.Response;\r\n\r\n@Path(\"/test\")\r\n@RequestScoped\r\npublic class TestResource {\r\n\r\n    @GET\r\n    @Produces(MediaType.APPLICATION_JSON)\r\n    public Response test() {\r\n        return Response.ok(\"{\\\"status\\\":\\\"API is working!\\\",\\\"message\\\":\\\"Soil Monitoring API is running\\\"}\").build();\r\n    }\r\n\r\n    @GET\r\n    @Path(\"/health\")\r\n    @Produces(MediaType.APPLICATION_JSON)\r\n    public Response health() {\r\n        return Response.ok(\"{\\\"status\\\":\\\"healthy\\\"}\").build();\r\n    }\r\n}\r\n",
      "info": {
        "size": 716,
        "last_modified": "2025-11-11T20:46:11.5809987",
        "mime_type": "text/x-java-source",
        "extension": ".java"
      }
    },
    {
      "path": "java\\me\\soilmonitoring\\api\\controllers\\managers\\SoilMonitoringManager.java",
      "content": "package me.soilmonitoring.api.controllers.managers;\r\n\r\nimport jakarta.inject.Inject;\r\nimport jakarta.inject.Singleton;\r\nimport me.soilmonitoring.api.controllers.repositories.*;\r\nimport me.soilmonitoring.api.entities.*;\r\n\r\nimport java.time.LocalDateTime;\r\nimport java.util.List;\r\nimport java.util.Optional;\r\n\r\n\r\n//TODO: add test file\r\n\r\n\r\n@Singleton\r\npublic class SoilMonitoringManager {\r\n\r\n    @Inject\r\n    private UserRepository userRepository;\r\n\r\n    @Inject\r\n    private FieldRepository fieldRepository;\r\n\r\n    @Inject\r\n    private SensorRepository sensorRepository;\r\n\r\n    @Inject\r\n    private SensorReadingRepository sensorReadingRepository;\r\n\r\n    @Inject\r\n    private PredictionRepository predictionRepository;\r\n\r\n    @Inject\r\n    private AlertRepository alertRepository;\r\n\r\n    @Inject\r\n    private TreatmentRepository treatmentRepository;\r\n\r\n    /* ******* user *********\r\n    */\r\n\r\n    /**\r\n     * Finds a user by their username.\r\n     *\r\n     * @param username the username of the user\r\n     * @return the User entity\r\n     * @throws IllegalArgumentException if no user is found\r\n     */\r\n\r\n    public User findUserByUsername(String username) {\r\n        return userRepository.findByUsername(username).orElseThrow(IllegalArgumentException::new);\r\n    }\r\n\r\n\r\n    /* ****** field *********\r\n     */\r\n\r\n    /**\r\n     * Finds a field by its ID.\r\n     *\r\n     * @param fieldId the ID of the field\r\n     * @return the Field entity\r\n     * @throws IllegalArgumentException if no field is found\r\n     */\r\n    public Field findFieldById(String fieldId) {\r\n        return fieldRepository.findById(fieldId).orElseThrow(IllegalArgumentException::new);\r\n    }\r\n\r\n\r\n    /**\r\n     * Gets all fields owned by a specific user.\r\n     *\r\n     * @param userId the ID of the user\r\n     * @return a list of fields owned by the user\r\n     */\r\n    public List<Field> getUserFields(String userId) {\r\n        return fieldRepository.findByUserId(userId);\r\n    }\r\n\r\n\r\n    /*  ***sensors******\r\n     */\r\n\r\n    /**\r\n     * Finds a sensor by its unique device ID.\r\n     *\r\n     * @param deviceId the device ID of the sensor\r\n     * @return the Sensor entity\r\n     * @throws IllegalArgumentException if no sensor is found\r\n     */\r\n    public Sensor findSensorByDeviceId(String deviceId) {\r\n        return sensorRepository.findByDeviceId(deviceId).orElseThrow(IllegalArgumentException::new);\r\n    }\r\n\r\n    /**\r\n     * Gets all sensors installed in a specific field.\r\n     *\r\n     * @param fieldId the ID of the field\r\n     * @return a list of sensors\r\n     */\r\n    public List<Sensor> getFieldSensors(String fieldId) {\r\n        return sensorRepository.findByFieldId(fieldId);\r\n    }\r\n\r\n\r\n    /* *****sensor reading ******\r\n    */\r\n\r\n\r\n    /**\r\n     * Gets all sensor readings for a specific field.\r\n     *\r\n     * @param fieldId the ID of the field\r\n     * @return a list of sensor readings\r\n     */\r\n    public List<SensorReading> getFieldReadings(String fieldId) {\r\n        return sensorReadingRepository.findByFieldId(fieldId);\r\n    }\r\n\r\n    /**\r\n     * Gets sensor readings for a specific field within a time range.\r\n     *\r\n     * @param fieldId the ID of the field\r\n     * @param from    the start of the time range\r\n     * @param to      the end of the time range\r\n     * @return a list of sensor readings\r\n     */\r\n    public List<SensorReading> getFieldReadingsByTimeRange(String fieldId, LocalDateTime from, LocalDateTime to) {\r\n        return sensorReadingRepository.findByFieldIdAndTimestampBetween(fieldId, from, to);\r\n    }\r\n\r\n    /* ******predictions******\r\n    */\r\n\r\n    /**\r\n     * Gets predictions for a specific field filtered by prediction type.\r\n     *\r\n     * @param fieldId        the ID of the field\r\n     * @param predictionType the type of prediction (\"crop\", \"fertilizer\")\r\n     * @return a list of predictions\r\n     */\r\n    public List<Prediction> getFieldPredictions(String fieldId, String predictionType) {\r\n        return predictionRepository.findByFieldIdAndPredictionType(fieldId, predictionType);\r\n    }\r\n\r\n    /* *******alerts******\r\n    */\r\n\r\n    /**\r\n     * Gets all unread alerts for a specific user.\r\n     *\r\n     * @param userId the ID of the user\r\n     * @return a list of unread alerts\r\n     */\r\n    public List<Alert> getUnreadAlerts(String userId) {\r\n        return alertRepository.findByUserIdAndIsRead(userId, false);\r\n    }\r\n\r\n    /* *****treatments******\r\n    */\r\n\r\n    /**\r\n     * Gets all treatments applied to a specific field.\r\n     *\r\n     * @param fieldId the ID of the field\r\n     * @return a list of treatments\r\n     */\r\n    public List<Treatment> getFieldTreatments(String fieldId) {\r\n        return treatmentRepository.findByFieldId(fieldId);\r\n    }\r\n\r\n\r\n\r\n\r\n}",
      "info": {
        "size": 4696,
        "last_modified": "2025-11-11T20:46:11.5843399",
        "mime_type": "text/x-java-source",
        "extension": ".java"
      }
    },
    {
      "path": "java\\me\\soilmonitoring\\api\\controllers\\repositories\\AlertRepository.java",
      "content": "package me.soilmonitoring.api.controllers.repositories;\r\n\r\nimport jakarta.data.repository.By;\r\nimport jakarta.data.repository.CrudRepository;\r\nimport jakarta.data.repository.Find;\r\nimport jakarta.data.repository.Repository;\r\nimport me.soilmonitoring.api.entities.Alert;\r\n\r\n\r\nimport java.util.List;\r\n\r\n//TODO: add test file\r\n\r\n@Repository\r\npublic interface AlertRepository extends CrudRepository<Alert, String> {\r\n\r\n    /**\r\n     * Finds all alerts belonging to a specific user.\r\n     *\r\n     * @param userId the ID of the user whose alerts are being retrieved\r\n     * @return a list of {@link Alert} objects associated with the specified user\r\n     */\r\n    @Find\r\n    List<Alert> findByUserId(@By(\"userId\") String userId);\r\n\r\n\r\n\r\n    /**\r\n     * Finds all alerts for a user filtered by their read status.\r\n     *\r\n     * @param userId the ID of the user whose alerts are being retrieved\r\n     * @param isRead a boolean value indicating whether to retrieve read or unread alerts\r\n     * @return a list of {@link Alert} objects matching the given criteria\r\n     */\r\n    @Find\r\n    List<Alert> findByUserIdAndIsRead(\r\n            @By(\"userId\") String userId,\r\n            @By(\"isRead\") Boolean isRead\r\n    );\r\n\r\n\r\n\r\n    /**\r\n     * Finds all alerts related to a specific field.\r\n     *\r\n     * This is useful when displaying alerts related to a given agricultural field\r\n     * in the PWAâ€™s prediction or monitoring dashboard.\r\n     *\r\n     *\r\n     * @param fieldId the ID of the field for which alerts are being retrieved\r\n     * @return a list of {@link Alert} objects associated with the specified field\r\n     */\r\n    @Find\r\n    List<Alert> findByFieldId(@By(\"fieldId\") String fieldId);\r\n}\r\n",
      "info": {
        "size": 1693,
        "last_modified": "2025-11-11T20:46:11.5878513",
        "mime_type": "text/x-java-source",
        "extension": ".java"
      }
    },
    {
      "path": "java\\me\\soilmonitoring\\api\\controllers\\repositories\\FieldRepository.java",
      "content": "\r\npackage me.soilmonitoring.api.controllers.repositories;\r\n\r\nimport jakarta.data.repository.By;\r\nimport jakarta.data.repository.CrudRepository;\r\nimport jakarta.data.repository.Find;\r\nimport jakarta.data.repository.Repository;\r\nimport me.soilmonitoring.api.entities.Field;\r\n\r\nimport java.util.List;\r\n\r\n//TODO: add test file\r\n\r\n@Repository\r\npublic interface FieldRepository extends CrudRepository<Field, String> {\r\n    /**\r\n     * Find all fields for a user\r\n     * @param userId\r\n     * @return all fields for a user\r\n     */\r\n    @Find\r\n    List<Field> findByUserId(@By(\"userId\") String userId);\r\n}",
      "info": {
        "size": 598,
        "last_modified": "2025-11-11T20:46:11.5908517",
        "mime_type": "text/x-java-source",
        "extension": ".java"
      }
    },
    {
      "path": "java\\me\\soilmonitoring\\api\\controllers\\repositories\\PredictionRepository.java",
      "content": "package me.soilmonitoring.api.controllers.repositories;\r\n\r\nimport jakarta.data.repository.By;\r\nimport jakarta.data.repository.CrudRepository;\r\nimport jakarta.data.repository.Find;\r\nimport jakarta.data.repository.Repository;\r\nimport me.soilmonitoring.api.entities.Prediction;\r\n\r\nimport java.time.LocalDateTime;\r\nimport java.util.List;\r\nimport java.util.Optional;\r\n\r\n//TODO: add test file\r\n\r\n@Repository\r\npublic interface PredictionRepository extends CrudRepository<Prediction, String> {\r\n\r\n    /**\r\n     * Finds all predictions associated with a specific field.\r\n     *\r\n     * @param fieldId the unique identifier of the field\r\n     * @return a list of all predictions related to that field\r\n     */\r\n    @Find\r\n    List<Prediction> findByFieldId(@By(\"fieldId\") String fieldId);\r\n\r\n\r\n    /**\r\n     * Finds all predictions for a given field and a specific prediction type\r\n     * (e.g., \"crop\" or \"fertilizer\").\r\n     *\r\n     * @param fieldId the field's unique identifier\r\n     * @param predictionType the type of prediction\r\n     * @return a list of predictions matching both field and type\r\n     */\r\n    @Find\r\n    List<Prediction> findByFieldIdAndPredictionType(\r\n            @By(\"fieldId\") String fieldId,\r\n            @By(\"predictionType\") String predictionType\r\n    );\r\n\r\n\r\n    /**\r\n     * Finds the latest prediction for a given field, based on creation timestamp.\r\n     *\r\n     * This is especially useful for real-time dashboards where the PWA needs\r\n     * to show the most recent prediction result (e.g., next irrigation time or best crop).\r\n     *\r\n     * @param fieldId the field's unique identifier\r\n     * @return the latest Prediction object if found\r\n     */\r\n    @Find\r\n    Optional<Prediction> findTopByFieldIdOrderByTimestampDesc(@By(\"fieldId\") String fieldId);\r\n\r\n\r\n    /**\r\n     * Finds all predictions for a specific field that were created after a certain timestamp.\r\n     *\r\n     * Useful for showing trends or prediction history (for example,\r\n     * all predictions generated in the last week or month).\r\n     *\r\n     * @param fieldId the field's unique identifier\r\n     * @param since the timestamp after which predictions should be retrieved\r\n     * @return a list of recent predictions for that field\r\n     */\r\n    @Find\r\n    List<Prediction> findByFieldIdAndTimestampAfter(\r\n            @By(\"fieldId\") String fieldId,\r\n            @By(\"timestamp\") LocalDateTime since\r\n    );\r\n\r\n\r\n    /**\r\n     * Counts how many predictions exist for a specific field.\r\n     *\r\n     * Useful for analytics or usage statistics in your PWA (e.g.,\r\n     * \"X predictions generated for Field A this week\").\r\n     *\r\n     * @param fieldId the field's unique identifier\r\n     * @return the number of predictions for that field\r\n     */\r\n    long countByFieldId(@By(\"fieldId\") String fieldId);\r\n}\r\n",
      "info": {
        "size": 2806,
        "last_modified": "2025-11-11T20:46:11.5928519",
        "mime_type": "text/x-java-source",
        "extension": ".java"
      }
    },
    {
      "path": "java\\me\\soilmonitoring\\api\\controllers\\repositories\\SensorReadingRepository.java",
      "content": "package me.soilmonitoring.api.controllers.repositories;\r\n\r\nimport jakarta.data.repository.By;\r\nimport jakarta.data.repository.CrudRepository;\r\nimport jakarta.data.repository.Find;\r\nimport jakarta.data.repository.Repository;\r\nimport me.soilmonitoring.api.entities.SensorReading;\r\n\r\nimport java.time.LocalDateTime;\r\nimport java.util.List;\r\n\r\n//TODO: add test file\r\n\r\n\r\n@Repository\r\npublic interface SensorReadingRepository extends CrudRepository<SensorReading, String> {\r\n\r\n    /**\r\n     * Retrieves all sensor readings associated with a specific field.\r\n     *\r\n     * This is typically used to display aggregated or historical data for\r\n     * all sensors in a given agricultural field.\r\n     *\r\n     *\r\n     * @param fieldId the unique identifier of the field\r\n     * @return a list of {@link SensorReading} objects linked to the specified field\r\n     */\r\n    @Find\r\n    List<SensorReading> findByFieldId(@By(\"fieldId\") String fieldId);\r\n\r\n    /**\r\n     * Retrieves all readings collected from a specific sensor.\r\n     *\r\n     * This allows the system to analyze or visualize time-series data\r\n     * for a single device, such as temperature, moisture, or pH readings.\r\n     *\r\n     *\r\n     * @param sensorId the unique identifier of the sensor\r\n     * @return a list of {@link SensorReading} objects recorded by the specified sensor\r\n     */\r\n    @Find\r\n    List<SensorReading> findBySensorId(@By(\"sensorId\") String sensorId);\r\n\r\n    /**\r\n     * Retrieves all readings for a specific field within a given time range.\r\n     *\r\n     * This query is useful for time-based analysis â€” for example, generating\r\n     * charts or predictions based on readings collected between two dates.\r\n     *\r\n     *\r\n     * @param fieldId the unique identifier of the field\r\n     * @param from    the start of the time interval\r\n     * @param to      the end of the time interval\r\n     * @return a list of {@link SensorReading} objects collected during the specified period\r\n     */\r\n    @Find\r\n    List<SensorReading> findByFieldIdAndTimestampBetween(\r\n            @By(\"fieldId\") String fieldId,\r\n            @By(\"timestamp\") LocalDateTime from,\r\n            @By(\"timestamp\") LocalDateTime to\r\n    );\r\n}\r\n",
      "info": {
        "size": 2191,
        "last_modified": "2025-11-11T20:46:11.5959235",
        "mime_type": "text/x-java-source",
        "extension": ".java"
      }
    },
    {
      "path": "java\\me\\soilmonitoring\\api\\controllers\\repositories\\SensorRepository.java",
      "content": "package me.soilmonitoring.api.controllers.repositories;\r\n\r\nimport jakarta.data.repository.By;\r\nimport jakarta.data.repository.CrudRepository;\r\nimport jakarta.data.repository.Find;\r\nimport jakarta.data.repository.Repository;\r\nimport me.soilmonitoring.api.entities.Sensor;\r\n\r\nimport java.util.List;\r\nimport java.util.Optional;\r\n\r\n//TODO: add test file\r\n\r\n@Repository\r\npublic interface SensorRepository extends CrudRepository<Sensor, String> {\r\n\r\n    /**\r\n     * Retrieves all sensors associated with a specific field.\r\n     *\r\n     * This is typically used to fetch all sensors deployed in a particular\r\n     * agricultural field to display their readings or statuses in the PWA dashboard.\r\n     *\r\n     *\r\n     * @param fieldId the unique identifier of the field\r\n     * @return a list of {@link Sensor} objects linked to the specified field\r\n     */\r\n    @Find\r\n    List<Sensor> findByFieldId(@By(\"fieldId\") String fieldId);\r\n\r\n\r\n\r\n    /**\r\n     * Retrieves a sensor based on its unique device ID.\r\n     *\r\n     * This method is useful for checking whether a sensor device is already registered\r\n     * in the system or when processing incoming data from IoT devices.\r\n     *\r\n     *\r\n     * @param deviceId the unique hardware or network identifier of the sensor device\r\n     * @return an {@link Optional} containing the {@link Sensor} if found, or empty if not found\r\n     */\r\n    @Find\r\n    Optional<Sensor> findByDeviceId(@By(\"deviceId\") String deviceId);\r\n\r\n\r\n\r\n    /**\r\n     * Retrieves all sensors that match a given operational status.\r\n     *\r\n     * The status may represent conditions such as \"ACTIVE\", \"INACTIVE\",\r\n     * \"FAULTY\", or \"DISCONNECTED\", allowing system administrators or automated\r\n     * services to monitor sensor health.\r\n     *\r\n     *\r\n     * @param status the operational status of the sensors\r\n     * @return a list of {@link Sensor} objects with the specified status\r\n     */\r\n    @Find\r\n    List<Sensor> findByStatus(@By(\"status\") String status);\r\n}\r\n",
      "info": {
        "size": 1986,
        "last_modified": "2025-11-11T20:46:11.5979296",
        "mime_type": "text/x-java-source",
        "extension": ".java"
      }
    },
    {
      "path": "java\\me\\soilmonitoring\\api\\controllers\\repositories\\TreatmentRepository.java",
      "content": "package me.soilmonitoring.api.controllers.repositories;\r\n\r\nimport jakarta.data.repository.By;\r\nimport jakarta.data.repository.CrudRepository;\r\nimport jakarta.data.repository.Find;\r\nimport jakarta.data.repository.Repository;\r\nimport me.soilmonitoring.api.entities.Treatment;\r\n\r\nimport java.util.List;\r\n\r\n//TODO: add test file\r\n\r\n@Repository\r\npublic interface TreatmentRepository extends CrudRepository<Treatment, String> {\r\n\r\n    /**\r\n     * Retrieves all treatments applied to a specific field.\r\n     *\r\n     * This method allows the platform to display the complete treatment history\r\n     * for a given field, which can be useful for monitoring crop care and\r\n     * evaluating productivity over time.\r\n     *\r\n     *\r\n     * @param fieldId the unique identifier of the field\r\n     * @return a list of {@link Treatment} entities associated with the specified field\r\n     */\r\n    @Find\r\n    List<Treatment> findByFieldId(@By(\"fieldId\") String fieldId);\r\n\r\n    /**\r\n     * Retrieves treatments of a specific type applied to a particular field.\r\n     *\r\n     * This query is useful when filtering treatment records, for instance,\r\n     * to show only irrigation or fertilization actions within a certain field.\r\n     *\r\n     *\r\n     * @param fieldId        the unique identifier of the field\r\n     * @param treatmentType  the type of treatment (e.g., \"irrigation\", \"fertilization\")\r\n     * @return a list of {@link Treatment} entities matching the specified criteria\r\n     */\r\n    @Find\r\n    List<Treatment> findByFieldIdAndTreatmentType(\r\n            @By(\"fieldId\") String fieldId,\r\n            @By(\"treatmentType\") String treatmentType\r\n    );\r\n}\r\n",
      "info": {
        "size": 1649,
        "last_modified": "2025-11-11T20:46:11.5999292",
        "mime_type": "text/x-java-source",
        "extension": ".java"
      }
    },
    {
      "path": "java\\me\\soilmonitoring\\api\\controllers\\repositories\\UserRepository.java",
      "content": "package me.soilmonitoring.api.controllers.repositories;\r\n\r\nimport jakarta.data.repository.By;\r\nimport jakarta.data.repository.CrudRepository;\r\nimport jakarta.data.repository.Find;\r\nimport jakarta.data.repository.Repository;\r\nimport me.soilmonitoring.api.entities.User;\r\n\r\nimport java.util.Optional;\r\n\r\n//TODO: add test file\r\n\r\n@Repository\r\npublic interface UserRepository extends CrudRepository<User, String> {\r\n\r\n    /**\r\n     * Retrieves a user by their unique username.\r\n     *\r\n     * This method is commonly used during authentication or when checking\r\n     * for duplicate usernames during registration.\r\n     *\r\n     *\r\n     * @param username the username of the user\r\n     * @return an {@link Optional} containing the {@link User} if found, or empty if not found\r\n     */\r\n    @Find\r\n    Optional<User> findByUsername(@By(\"username\") String username);\r\n\r\n    /**\r\n     * Retrieves a user by their unique email address.\r\n     *\r\n     * This method is useful for authentication, password recovery,\r\n     * or checking if an email is already registered in the system.\r\n     *\r\n     *\r\n     * @param email the email of the user\r\n     * @return an {@link Optional} containing the {@link User} if found, or empty if not found\r\n     */\r\n    @Find\r\n    Optional<User> findByEmail(@By(\"email\") String email);\r\n}\r\n",
      "info": {
        "size": 1312,
        "last_modified": "2025-11-11T20:46:11.6029309",
        "mime_type": "text/x-java-source",
        "extension": ".java"
      }
    },
    {
      "path": "java\\me\\soilmonitoring\\api\\entities\\Alert.java",
      "content": "package me.soilmonitoring.api.entities;\r\n\r\nimport jakarta.nosql.Column;\r\nimport jakarta.nosql.Entity;\r\nimport jakarta.nosql.Id;\r\n\r\nimport java.time.LocalDateTime;\r\n\r\n// TODO: add documentation\r\n\r\n@Entity\r\npublic class Alert implements RootEntity<String> {\r\n    @Id\r\n    private String id;\r\n\r\n    @Column\r\n    private long version = 0L;\r\n\r\n    @Column\r\n    private String userId;\r\n\r\n    @Column\r\n    private String fieldId;\r\n\r\n    @Column\r\n    private String alertType; // \"temperature\", \"humidity\", \"npk_deficiency\", \"moisture\"\r\n\r\n    @Column\r\n    private String severity; // \"low\", \"medium\", \"high\"\r\n\r\n    @Column\r\n    private String message;\r\n\r\n    @Column\r\n    private Boolean isRead;\r\n\r\n    @Column\r\n    private LocalDateTime createdAt;\r\n\r\n    @Override\r\n    public String getId() {\r\n        return id;\r\n    }\r\n\r\n    @Override\r\n    public void setId(String id) {\r\n        this.id = id;\r\n    }\r\n\r\n    @Override\r\n    public long getVersion() {\r\n        return version;\r\n    }\r\n\r\n    @Override\r\n    public void setVersion(long version) {\r\n        if (this.version != version) {\r\n            throw new IllegalStateException();\r\n        }\r\n        ++this.version;\r\n    }\r\n\r\n    public String getUserId() {\r\n        return userId;\r\n    }\r\n\r\n    public void setUserId(String userId) {\r\n        this.userId = userId;\r\n    }\r\n\r\n    public String getFieldId() {\r\n        return fieldId;\r\n    }\r\n\r\n    public void setFieldId(String fieldId) {\r\n        this.fieldId = fieldId;\r\n    }\r\n\r\n    public String getAlertType() {\r\n        return alertType;\r\n    }\r\n\r\n    public void setAlertType(String alertType) {\r\n        this.alertType = alertType;\r\n    }\r\n\r\n    public String getSeverity() {\r\n        return severity;\r\n    }\r\n\r\n    public void setSeverity(String severity) {\r\n        this.severity = severity;\r\n    }\r\n\r\n    public String getMessage() {\r\n        return message;\r\n    }\r\n\r\n    public void setMessage(String message) {\r\n        this.message = message;\r\n    }\r\n\r\n    public Boolean getIsRead() {\r\n        return isRead;\r\n    }\r\n\r\n    public void setIsRead(Boolean isRead) {\r\n        this.isRead = isRead;\r\n    }\r\n\r\n    public LocalDateTime getCreatedAt() {\r\n        return createdAt;\r\n    }\r\n\r\n    public void setCreatedAt(LocalDateTime createdAt) {\r\n        this.createdAt = createdAt;\r\n    }\r\n}",
      "info": {
        "size": 2298,
        "last_modified": "2025-11-11T20:46:11.6070789",
        "mime_type": "text/x-java-source",
        "extension": ".java"
      }
    },
    {
      "path": "java\\me\\soilmonitoring\\api\\entities\\Field.java",
      "content": "package me.soilmonitoring.api.entities;\r\n\r\nimport jakarta.nosql.Column;\r\nimport jakarta.nosql.Entity;\r\nimport jakarta.nosql.Id;\r\n\r\nimport java.time.LocalDateTime;\r\n\r\n// TODO: add documentation\r\n\r\n@Entity\r\npublic class Field implements RootEntity<String> {\r\n    @Id\r\n    private String id;\r\n\r\n    @Column\r\n    private long version = 0L;\r\n\r\n    @Column\r\n    private String userId; // Owner\r\n\r\n    @Column\r\n    private String name;\r\n\r\n    @Column\r\n    private Location location;\r\n\r\n    @Column\r\n    private Double area; // in hectares\r\n\r\n    @Column\r\n    private String currentCrop;\r\n\r\n    @Column\r\n    private String soilType;\r\n\r\n    @Column\r\n    private LocalDateTime createdAt;\r\n\r\n    @Override\r\n    public String getId() {\r\n        return id;\r\n    }\r\n\r\n    @Override\r\n    public void setId(String id) {\r\n        this.id = id;\r\n    }\r\n\r\n    @Override\r\n    public long getVersion() {\r\n        return version;\r\n    }\r\n\r\n    @Override\r\n    public void setVersion(long version) {\r\n        if (this.version != version) {\r\n            throw new IllegalStateException();\r\n        }\r\n        ++this.version;\r\n    }\r\n\r\n    public String getUserId() {\r\n        return userId;\r\n    }\r\n\r\n    public void setUserId(String userId) {\r\n        this.userId = userId;\r\n    }\r\n\r\n    public String getName() {\r\n        return name;\r\n    }\r\n\r\n    public void setName(String name) {\r\n        this.name = name;\r\n    }\r\n\r\n    public Location getLocation() {\r\n        return location;\r\n    }\r\n\r\n    public void setLocation(Location location) {\r\n        this.location = location;\r\n    }\r\n\r\n    public Double getArea() {\r\n        return area;\r\n    }\r\n\r\n    public void setArea(Double area) {\r\n        this.area = area;\r\n    }\r\n\r\n    public String getCurrentCrop() {\r\n        return currentCrop;\r\n    }\r\n\r\n    public void setCurrentCrop(String currentCrop) {\r\n        this.currentCrop = currentCrop;\r\n    }\r\n\r\n    public String getSoilType() {\r\n        return soilType;\r\n    }\r\n\r\n    public void setSoilType(String soilType) {\r\n        this.soilType = soilType;\r\n    }\r\n\r\n    public LocalDateTime getCreatedAt() {\r\n        return createdAt;\r\n    }\r\n\r\n    public void setCreatedAt(LocalDateTime createdAt) {\r\n        this.createdAt = createdAt;\r\n    }\r\n}",
      "info": {
        "size": 2225,
        "last_modified": "2025-11-11T20:46:11.6101969",
        "mime_type": "text/x-java-source",
        "extension": ".java"
      }
    },
    {
      "path": "java\\me\\soilmonitoring\\api\\entities\\Location.java",
      "content": "package me.soilmonitoring.api.entities;\r\n\r\nimport jakarta.nosql.Column;\r\nimport jakarta.nosql.Embeddable;\r\n\r\n\r\n// TODO: add documentation\r\n\r\n@Embeddable\r\npublic class Location {\r\n    @Column\r\n    private Double latitude;\r\n\r\n    @Column\r\n    private Double longitude;\r\n\r\n    @Column\r\n    private String address;\r\n\r\n    public Location() {\r\n    }\r\n\r\n    public Location(Double latitude, Double longitude, String address) {\r\n        this.latitude = latitude;\r\n        this.longitude = longitude;\r\n        this.address = address;\r\n    }\r\n\r\n    public Double getLatitude() {\r\n        return latitude;\r\n    }\r\n\r\n    public void setLatitude(Double latitude) {\r\n        this.latitude = latitude;\r\n    }\r\n\r\n    public Double getLongitude() {\r\n        return longitude;\r\n    }\r\n\r\n    public void setLongitude(Double longitude) {\r\n        this.longitude = longitude;\r\n    }\r\n\r\n    public String getAddress() {\r\n        return address;\r\n    }\r\n\r\n    public void setAddress(String address) {\r\n        this.address = address;\r\n    }\r\n}\r\n",
      "info": {
        "size": 1023,
        "last_modified": "2025-11-11T20:46:11.6122028",
        "mime_type": "text/x-java-source",
        "extension": ".java"
      }
    },
    {
      "path": "java\\me\\soilmonitoring\\api\\entities\\Prediction.java",
      "content": "package me.soilmonitoring.api.entities;\r\n\r\nimport jakarta.nosql.Column;\r\nimport jakarta.nosql.Embeddable;\r\nimport jakarta.nosql.Entity;\r\nimport jakarta.nosql.Id;\r\n\r\nimport java.time.LocalDateTime;\r\nimport java.util.List;\r\n\r\n\r\n// TODO: add documentation\r\n\r\n\r\n@Entity\r\npublic class Prediction implements RootEntity<String> {\r\n    @Id\r\n    private String id;\r\n\r\n    @Column\r\n    private long version = 0L;\r\n\r\n    @Column\r\n    private String fieldId;\r\n\r\n    @Column\r\n    private String predictionType; // \"crop\", \"fertilizer\"\r\n\r\n    @Column\r\n    private String modelUsed; // \"CatBoost\", \"RandomForest\"\r\n\r\n    @Column\r\n    private PredictionInput inputData;\r\n\r\n    @Column\r\n    private PredictionResult result;\r\n\r\n    @Column\r\n    private Double confidence;\r\n\r\n    @Column\r\n    private LocalDateTime createdAt;\r\n\r\n    @Override\r\n    public String getId() {\r\n        return id;\r\n    }\r\n\r\n    @Override\r\n    public void setId(String id) {\r\n        this.id = id;\r\n    }\r\n\r\n    @Override\r\n    public long getVersion() {\r\n        return version;\r\n    }\r\n\r\n    @Override\r\n    public void setVersion(long version) {\r\n        if (this.version != version) {\r\n            throw new IllegalStateException();\r\n        }\r\n        ++this.version;\r\n    }\r\n\r\n    public String getFieldId() {\r\n        return fieldId;\r\n    }\r\n\r\n    public void setFieldId(String fieldId) {\r\n        this.fieldId = fieldId;\r\n    }\r\n\r\n    public String getPredictionType() {\r\n        return predictionType;\r\n    }\r\n\r\n    public void setPredictionType(String predictionType) {\r\n        this.predictionType = predictionType;\r\n    }\r\n\r\n    public String getModelUsed() {\r\n        return modelUsed;\r\n    }\r\n\r\n    public void setModelUsed(String modelUsed) {\r\n        this.modelUsed = modelUsed;\r\n    }\r\n\r\n    public PredictionInput getInputData() {\r\n        return inputData;\r\n    }\r\n\r\n    public void setInputData(PredictionInput inputData) {\r\n        this.inputData = inputData;\r\n    }\r\n\r\n    public PredictionResult getResult() {\r\n        return result;\r\n    }\r\n\r\n    public void setResult(PredictionResult result) {\r\n        this.result = result;\r\n    }\r\n\r\n    public Double getConfidence() {\r\n        return confidence;\r\n    }\r\n\r\n    public void setConfidence(Double confidence) {\r\n        this.confidence = confidence;\r\n    }\r\n\r\n    public LocalDateTime getCreatedAt() {\r\n        return createdAt;\r\n    }\r\n\r\n    public void setCreatedAt(LocalDateTime createdAt) {\r\n        this.createdAt = createdAt;\r\n    }\r\n\r\n    @Embeddable\r\n    public static class PredictionInput {\r\n        // Common inputs for both models\r\n        @Column\r\n        private Double nitrogen;\r\n\r\n        @Column\r\n        private Double phosphorus;\r\n\r\n        @Column\r\n        private Double potassium;\r\n\r\n        @Column\r\n        private Double temperature;\r\n\r\n        @Column\r\n        private Double humidity;\r\n\r\n        @Column\r\n        private Double soilMoisture;\r\n\r\n        // Additional inputs for fertilizer recommendation\r\n        @Column\r\n        private String soilType; // For fertilizer model\r\n\r\n        @Column\r\n        private String cropType; // For fertilizer model\r\n\r\n        // Getters and Setters\r\n        public Double getNitrogen() { return nitrogen; }\r\n        public void setNitrogen(Double nitrogen) { this.nitrogen = nitrogen; }\r\n\r\n        public Double getPhosphorus() { return phosphorus; }\r\n        public void setPhosphorus(Double phosphorus) { this.phosphorus = phosphorus; }\r\n\r\n        public Double getPotassium() { return potassium; }\r\n        public void setPotassium(Double potassium) { this.potassium = potassium; }\r\n\r\n        public Double getTemperature() { return temperature; }\r\n        public void setTemperature(Double temperature) { this.temperature = temperature; }\r\n\r\n        public Double getHumidity() { return humidity; }\r\n        public void setHumidity(Double humidity) { this.humidity = humidity; }\r\n\r\n        public Double getSoilMoisture() { return soilMoisture; }\r\n        public void setSoilMoisture(Double soilMoisture) { this.soilMoisture = soilMoisture; }\r\n\r\n        public String getSoilType() { return soilType; }\r\n        public void setSoilType(String soilType) { this.soilType = soilType; }\r\n\r\n        public String getCropType() { return cropType; }\r\n        public void setCropType(String cropType) { this.cropType = cropType; }\r\n    }\r\n\r\n    @Embeddable\r\n    public static class PredictionResult {\r\n        @Column\r\n        private String recommendation; // Crop name or fertilizer type\r\n\r\n        @Column\r\n        private String dosage; // For fertilizer\r\n\r\n        @Column\r\n        private List<String> details;\r\n\r\n        // Getters and Setters\r\n        public String getRecommendation() { return recommendation; }\r\n        public void setRecommendation(String recommendation) { this.recommendation = recommendation; }\r\n\r\n        public String getDosage() { return dosage; }\r\n        public void setDosage(String dosage) { this.dosage = dosage; }\r\n\r\n        public List<String> getDetails() { return details; }\r\n        public void setDetails(List<String> details) { this.details = details; }\r\n    }\r\n}",
      "info": {
        "size": 5102,
        "last_modified": "2025-11-11T20:46:11.6147079",
        "mime_type": "text/x-java-source",
        "extension": ".java"
      }
    },
    {
      "path": "java\\me\\soilmonitoring\\api\\entities\\RootEntity.java",
      "content": "package me.soilmonitoring.api.entities;\r\n\r\nimport java.io.Serializable;\r\n\r\n\r\n// TODO: add documentation\r\n\r\n\r\npublic interface RootEntity<ID extends Serializable> extends Serializable {\r\n    ID getId();\r\n    void setId(ID id);\r\n    long getVersion();\r\n    void setVersion(long version);\r\n}\r\n",
      "info": {
        "size": 290,
        "last_modified": "2025-11-11T20:46:11.6167138",
        "mime_type": "text/x-java-source",
        "extension": ".java"
      }
    },
    {
      "path": "java\\me\\soilmonitoring\\api\\entities\\Sensor.java",
      "content": "package me.soilmonitoring.api.entities;\r\n\r\nimport jakarta.nosql.Column;\r\nimport jakarta.nosql.Entity;\r\nimport jakarta.nosql.Id;\r\n\r\nimport java.time.LocalDateTime;\r\n\r\n\r\n// TODO: add documentation\r\n\r\n\r\n@Entity\r\npublic class Sensor implements RootEntity<String> {\r\n    @Id\r\n    private String id;\r\n\r\n    @Column\r\n    private long version = 0L;\r\n\r\n    @Column\r\n    private String fieldId;\r\n\r\n    @Column\r\n    private String sensorType; // \"DHT22\", \"NPK\"\r\n\r\n    @Column\r\n    private String deviceId; // Raspberry Pi unique ID\r\n\r\n    @Column\r\n    private String status; // \"active\", \"inactive\", \"error\"\r\n\r\n    @Column\r\n    private LocalDateTime lastConnection;\r\n\r\n    @Column\r\n    private LocalDateTime installedAt;\r\n\r\n    @Override\r\n    public String getId() {\r\n        return id;\r\n    }\r\n\r\n    @Override\r\n    public void setId(String id) {\r\n        this.id = id;\r\n    }\r\n\r\n    @Override\r\n    public long getVersion() {\r\n        return version;\r\n    }\r\n\r\n    @Override\r\n    public void setVersion(long version) {\r\n        if (this.version != version) {\r\n            throw new IllegalStateException();\r\n        }\r\n        ++this.version;\r\n    }\r\n\r\n    public String getFieldId() {\r\n        return fieldId;\r\n    }\r\n\r\n    public void setFieldId(String fieldId) {\r\n        this.fieldId = fieldId;\r\n    }\r\n\r\n    public String getSensorType() {\r\n        return sensorType;\r\n    }\r\n\r\n    public void setSensorType(String sensorType) {\r\n        this.sensorType = sensorType;\r\n    }\r\n\r\n    public String getDeviceId() {\r\n        return deviceId;\r\n    }\r\n\r\n    public void setDeviceId(String deviceId) {\r\n        this.deviceId = deviceId;\r\n    }\r\n\r\n    public String getStatus() {\r\n        return status;\r\n    }\r\n\r\n    public void setStatus(String status) {\r\n        this.status = status;\r\n    }\r\n\r\n    public LocalDateTime getLastConnection() {\r\n        return lastConnection;\r\n    }\r\n\r\n    public void setLastConnection(LocalDateTime lastConnection) {\r\n        this.lastConnection = lastConnection;\r\n    }\r\n\r\n    public LocalDateTime getInstalledAt() {\r\n        return installedAt;\r\n    }\r\n\r\n    public void setInstalledAt(LocalDateTime installedAt) {\r\n        this.installedAt = installedAt;\r\n    }\r\n}\r\n",
      "info": {
        "size": 2191,
        "last_modified": "2025-11-11T20:46:11.6187175",
        "mime_type": "text/x-java-source",
        "extension": ".java"
      }
    },
    {
      "path": "java\\me\\soilmonitoring\\api\\entities\\SensorData.java",
      "content": "package me.soilmonitoring.api.entities;\r\n\r\nimport jakarta.nosql.Column;\r\nimport jakarta.nosql.Embeddable;\r\n\r\n\r\n// TODO: add documentation\r\n\r\n\r\n@Embeddable\r\npublic class SensorData {\r\n    @Column\r\n    private Double temperature;\r\n\r\n    @Column\r\n    private Double humidity;\r\n\r\n    @Column\r\n    private Double nitrogen;\r\n\r\n    @Column\r\n    private Double phosphorus;\r\n\r\n    @Column\r\n    private Double potassium;\r\n\r\n    @Column\r\n    private Double soilMoisture;\r\n\r\n    @Column\r\n    private Double rainfall;\r\n\r\n    @Column\r\n    private Double pH;\r\n\r\n    public SensorData() {\r\n    }\r\n\r\n    public Double getTemperature() {\r\n        return temperature;\r\n    }\r\n\r\n    public void setTemperature(Double temperature) {\r\n        this.temperature = temperature;\r\n    }\r\n\r\n    public Double getHumidity() {\r\n        return humidity;\r\n    }\r\n\r\n    public void setHumidity(Double humidity) {\r\n        this.humidity = humidity;\r\n    }\r\n\r\n    public Double getNitrogen() {\r\n        return nitrogen;\r\n    }\r\n\r\n    public void setNitrogen(Double nitrogen) {\r\n        this.nitrogen = nitrogen;\r\n    }\r\n\r\n    public Double getPhosphorus() {\r\n        return phosphorus;\r\n    }\r\n\r\n    public void setPhosphorus(Double phosphorus) {\r\n        this.phosphorus = phosphorus;\r\n    }\r\n\r\n    public Double getPotassium() {\r\n        return potassium;\r\n    }\r\n\r\n    public void setPotassium(Double potassium) {\r\n        this.potassium = potassium;\r\n    }\r\n\r\n    public Double getSoilMoisture() {\r\n        return soilMoisture;\r\n    }\r\n\r\n    public void setSoilMoisture(Double soilMoisture) {\r\n        this.soilMoisture = soilMoisture;\r\n    }\r\n\r\n    public Double getRainfall() {\r\n        return rainfall;\r\n    }\r\n\r\n    public void setRainfall(Double rainfall) {\r\n        this.rainfall = rainfall;\r\n    }\r\n\r\n    public Double getPh() {\r\n        return rainfall;\r\n    }\r\n\r\n    public void setPh(Double pH) {\r\n        this.pH = pH;\r\n    }\r\n}",
      "info": {
        "size": 1908,
        "last_modified": "2025-11-11T20:46:11.6207195",
        "mime_type": "text/x-java-source",
        "extension": ".java"
      }
    },
    {
      "path": "java\\me\\soilmonitoring\\api\\entities\\SensorReading.java",
      "content": "package me.soilmonitoring.api.entities;\r\n\r\nimport jakarta.nosql.Column;\r\nimport jakarta.nosql.Entity;\r\nimport jakarta.nosql.Id;\r\n\r\nimport java.time.LocalDateTime;\r\n\r\n\r\n// TODO: add documentation\r\n\r\n\r\n@Entity\r\npublic class SensorReading implements RootEntity<String> {\r\n    @Id\r\n    private String id;\r\n\r\n    @Column\r\n    private long version = 0L;\r\n\r\n    @Column\r\n    private String sensorId;\r\n\r\n    @Column\r\n    private String fieldId;\r\n\r\n    @Column\r\n    private LocalDateTime timestamp;\r\n\r\n    @Column\r\n    private SensorData data;\r\n\r\n    @Override\r\n    public String getId() {\r\n        return id;\r\n    }\r\n\r\n    @Override\r\n    public void setId(String id) {\r\n        this.id = id;\r\n    }\r\n\r\n    @Override\r\n    public long getVersion() {\r\n        return version;\r\n    }\r\n\r\n    @Override\r\n    public void setVersion(long version) {\r\n        if (this.version != version) {\r\n            throw new IllegalStateException();\r\n        }\r\n        ++this.version;\r\n    }\r\n\r\n    public String getSensorId() {\r\n        return sensorId;\r\n    }\r\n\r\n    public void setSensorId(String sensorId) {\r\n        this.sensorId = sensorId;\r\n    }\r\n\r\n    public String getFieldId() {\r\n        return fieldId;\r\n    }\r\n\r\n    public void setFieldId(String fieldId) {\r\n        this.fieldId = fieldId;\r\n    }\r\n\r\n    public LocalDateTime getTimestamp() {\r\n        return timestamp;\r\n    }\r\n\r\n    public void setTimestamp(LocalDateTime timestamp) {\r\n        this.timestamp = timestamp;\r\n    }\r\n\r\n    public SensorData getData() {\r\n        return data;\r\n    }\r\n\r\n    public void setData(SensorData data) {\r\n        this.data = data;\r\n    }\r\n}\r\n",
      "info": {
        "size": 1614,
        "last_modified": "2025-11-11T20:46:11.622744",
        "mime_type": "text/x-java-source",
        "extension": ".java"
      }
    },
    {
      "path": "java\\me\\soilmonitoring\\api\\entities\\Treatment.java",
      "content": "package me.soilmonitoring.api.entities;\r\n\r\nimport jakarta.nosql.Column;\r\nimport jakarta.nosql.Entity;\r\nimport jakarta.nosql.Id;\r\n\r\nimport java.time.LocalDateTime;\r\n\r\n\r\n// TODO: add documentation\r\n\r\n\r\n@Entity\r\npublic class Treatment implements RootEntity<String> {\r\n    @Id\r\n    private String id;\r\n\r\n    @Column\r\n    private long version = 0L;\r\n\r\n    @Column\r\n    private String fieldId;\r\n\r\n    @Column\r\n    private String treatmentType; // \"fertilizer\", \"pesticide\", \"irrigation\"\r\n\r\n    @Column\r\n    private String productName;\r\n\r\n    @Column\r\n    private String quantity;\r\n\r\n    @Column\r\n    private LocalDateTime appliedAt;\r\n\r\n    @Column\r\n    private String appliedBy; // userId\r\n\r\n    @Column\r\n    private String notes;\r\n\r\n    @Override\r\n    public String getId() {\r\n        return id;\r\n    }\r\n\r\n    @Override\r\n    public void setId(String id) {\r\n        this.id = id;\r\n    }\r\n\r\n    @Override\r\n    public long getVersion() {\r\n        return version;\r\n    }\r\n\r\n    @Override\r\n    public void setVersion(long version) {\r\n        if (this.version != version) {\r\n            throw new IllegalStateException();\r\n        }\r\n        ++this.version;\r\n    }\r\n\r\n    public String getFieldId() {\r\n        return fieldId;\r\n    }\r\n\r\n    public void setFieldId(String fieldId) {\r\n        this.fieldId = fieldId;\r\n    }\r\n\r\n    public String getTreatmentType() {\r\n        return treatmentType;\r\n    }\r\n\r\n    public void setTreatmentType(String treatmentType) {\r\n        this.treatmentType = treatmentType;\r\n    }\r\n\r\n    public String getProductName() {\r\n        return productName;\r\n    }\r\n\r\n    public void setProductName(String productName) {\r\n        this.productName = productName;\r\n    }\r\n\r\n    public String getQuantity() {\r\n        return quantity;\r\n    }\r\n\r\n    public void setQuantity(String quantity) {\r\n        this.quantity = quantity;\r\n    }\r\n\r\n    public LocalDateTime getAppliedAt() {\r\n        return appliedAt;\r\n    }\r\n\r\n    public void setAppliedAt(LocalDateTime appliedAt) {\r\n        this.appliedAt = appliedAt;\r\n    }\r\n\r\n    public String getAppliedBy() {\r\n        return appliedBy;\r\n    }\r\n\r\n    public void setAppliedBy(String appliedBy) {\r\n        this.appliedBy = appliedBy;\r\n    }\r\n\r\n    public String getNotes() {\r\n        return notes;\r\n    }\r\n\r\n    public void setNotes(String notes) {\r\n        this.notes = notes;\r\n    }\r\n}",
      "info": {
        "size": 2340,
        "last_modified": "2025-11-11T20:46:11.6252212",
        "mime_type": "text/x-java-source",
        "extension": ".java"
      }
    },
    {
      "path": "java\\me\\soilmonitoring\\api\\entities\\User.java",
      "content": "package me.soilmonitoring.api.entities;\r\n\r\nimport jakarta.nosql.Column;\r\nimport jakarta.nosql.Entity;\r\nimport jakarta.nosql.Id;\r\n\r\nimport java.time.LocalDateTime;\r\n\r\n\r\n\r\n// TODO: add documentation\r\n\r\n\r\n@Entity\r\npublic class User implements RootEntity<String> {\r\n    @Id\r\n    private String id;\r\n\r\n    @Column\r\n    private long version = 0L;\r\n\r\n    @Column\r\n    private String username;\r\n\r\n    @Column\r\n    private String email;\r\n\r\n    @Column\r\n    private String fullName;\r\n\r\n    @Column\r\n    private String role; // \"farmer\", \"admin\"\r\n\r\n    @Column\r\n    private LocalDateTime createdAt;\r\n\r\n    @Override\r\n    public String getId() {\r\n        return id;\r\n    }\r\n\r\n    @Override\r\n    public void setId(String id) {\r\n        this.id = id;\r\n    }\r\n\r\n    @Override\r\n    public long getVersion() {\r\n        return version;\r\n    }\r\n\r\n    @Override\r\n    public void setVersion(long version) {\r\n        if (this.version != version) {\r\n            throw new IllegalStateException();\r\n        }\r\n        ++this.version;\r\n    }\r\n\r\n    public String getUsername() {\r\n        return username;\r\n    }\r\n\r\n    public void setUsername(String username) {\r\n        this.username = username;\r\n    }\r\n\r\n    public String getEmail() {\r\n        return email;\r\n    }\r\n\r\n    public void setEmail(String email) {\r\n        this.email = email;\r\n    }\r\n\r\n    public String getFullName() {\r\n        return fullName;\r\n    }\r\n\r\n    public void setFullName(String fullName) {\r\n        this.fullName = fullName;\r\n    }\r\n\r\n    public String getRole() {\r\n        return role;\r\n    }\r\n\r\n    public void setRole(String role) {\r\n        this.role = role;\r\n    }\r\n\r\n    public LocalDateTime getCreatedAt() {\r\n        return createdAt;\r\n    }\r\n\r\n    public void setCreatedAt(LocalDateTime createdAt) {\r\n        this.createdAt = createdAt;\r\n    }\r\n}",
      "info": {
        "size": 1807,
        "last_modified": "2025-11-11T20:46:11.6272533",
        "mime_type": "text/x-java-source",
        "extension": ".java"
      }
    },
    {
      "path": "java\\me\\soilmonitoring\\api\\mqtt\\MQTTService.java",
      "content": "package me.soilmonitoring.api.mqtt;\r\n\r\nimport com.hivemq.client.mqtt.MqttClient;\r\nimport com.hivemq.client.mqtt.mqtt5.Mqtt5AsyncClient;\r\nimport com.hivemq.client.mqtt.mqtt5.message.publish.Mqtt5Publish;\r\nimport jakarta.annotation.PostConstruct;\r\nimport jakarta.annotation.PreDestroy;\r\nimport jakarta.ejb.Singleton;\r\nimport jakarta.ejb.Startup;\r\nimport jakarta.inject.Inject;\r\nimport jakarta.json.Json;\r\nimport jakarta.json.JsonObject;\r\nimport jakarta.json.JsonReader;\r\nimport me.soilmonitoring.api.controllers.repositories.SensorReadingRepository;\r\nimport me.soilmonitoring.api.controllers.repositories.SensorRepository;\r\nimport me.soilmonitoring.api.entities.Sensor;\r\nimport me.soilmonitoring.api.entities.SensorData;\r\nimport me.soilmonitoring.api.entities.SensorReading;\r\nimport org.eclipse.microprofile.config.inject.ConfigProperty;\r\n\r\nimport java.io.StringReader;\r\nimport java.nio.charset.StandardCharsets;\r\nimport java.time.LocalDateTime;\r\nimport java.util.UUID;\r\nimport java.util.logging.Logger;\r\n\r\nimport static java.nio.charset.StandardCharsets.UTF_8;\r\n\r\n@Singleton\r\n@Startup\r\npublic class MQTTService {\r\n\r\n    private static final Logger logger = Logger.getLogger(MQTTService.class.getName());\r\n\r\n    @Inject\r\n    private SensorRepository sensorRepository;\r\n\r\n    @Inject\r\n    private SensorReadingRepository readingRepository;\r\n\r\n    @Inject\r\n    @ConfigProperty(name = \"mqtt.broker.url\")\r\n    private String brokerUrl;\r\n\r\n    @Inject\r\n    @ConfigProperty(name = \"mqtt.broker.port\")\r\n    private Integer brokerPort;\r\n\r\n    @Inject\r\n    @ConfigProperty(name = \"mqtt.username\")\r\n    private String username;\r\n\r\n    @Inject\r\n    @ConfigProperty(name = \"mqtt.password\")\r\n    private String password;\r\n\r\n    @Inject\r\n    @ConfigProperty(name = \"mqtt.client.id\")\r\n    private String clientId;\r\n\r\n    @Inject\r\n    @ConfigProperty(name = \"mqtt.use.tls\", defaultValue = \"true\")\r\n    private Boolean useTls;\r\n\r\n    private Mqtt5AsyncClient mqttClient;\r\n\r\n    @PostConstruct\r\n    public void init() {\r\n        try {\r\n            logger.info(\"ðŸš€ Initializing MQTT 5 connection to HiveMQ Cloud...\");\r\n\r\n            // Build MQTT 5 client\r\n            var clientBuilder = MqttClient.builder()\r\n                    .useMqttVersion5()\r\n                    .identifier(clientId + \"-\" + UUID.randomUUID())\r\n                    .serverHost(brokerUrl)\r\n                    .serverPort(brokerPort);\r\n\r\n            if (useTls) {\r\n                clientBuilder.sslWithDefaultConfig();\r\n            }\r\n\r\n            mqttClient = clientBuilder.buildAsync();\r\n\r\n            // Connect with credentials\r\n            mqttClient.connectWith()\r\n                    .simpleAuth()\r\n                    .username(username)\r\n                    .password(UTF_8.encode(password))\r\n                    .applySimpleAuth()\r\n                    .send()\r\n                    .whenComplete((connAck, throwable) -> {\r\n                        if (throwable != null) {\r\n                            logger.severe(\"âŒ Failed to connect to MQTT broker: \" + throwable.getMessage());\r\n                        } else {\r\n                            logger.info(\"âœ… Connected to HiveMQ Cloud successfully!\");\r\n                            subscribeToSensorData();\r\n                        }\r\n                    });\r\n\r\n        } catch (Exception e) {\r\n            logger.severe(\"Error initializing MQTT service: \" + e.getMessage());\r\n            e.printStackTrace();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Subscribe to the combined topic from Node-RED\r\n     */\r\n    private void subscribeToSensorData() {\r\n        String topic = \"sensor/data\";\r\n\r\n        mqttClient.subscribeWith()\r\n                .topicFilter(topic)\r\n                .callback(this::handleSensorData)\r\n                .send()\r\n                .whenComplete((subAck, throwable) -> {\r\n                    if (throwable != null) {\r\n                        logger.severe(\"âŒ Failed to subscribe to topic '\" + topic + \"': \" + throwable.getMessage());\r\n                    } else {\r\n                        logger.info(\"ðŸ“¡ Subscribed to topic: \" + topic);\r\n                    }\r\n                });\r\n    }\r\n\r\n    /**\r\n     * Handle incoming full sensor data payload\r\n     */\r\n    private void handleSensorData(Mqtt5Publish publish) {\r\n        try {\r\n            String payload = new String(publish.getPayloadAsBytes(), StandardCharsets.UTF_8);\r\n            logger.info(\"ðŸ“¥ Received payload: \" + payload);\r\n\r\n            JsonReader reader = Json.createReader(new StringReader(payload));\r\n            JsonObject json = reader.readObject();\r\n\r\n            // Parse all fields\r\n            String deviceId = json.getString(\"deviceId\", \"unknown-device\");\r\n            String fieldId = json.getString(\"fieldId\", \"default-field\");\r\n\r\n            SensorData data = new SensorData();\r\n            if (json.containsKey(\"temperature\"))\r\n                data.setTemperature(json.getJsonNumber(\"temperature\").doubleValue());\r\n            if (json.containsKey(\"humidity\"))\r\n                data.setHumidity(json.getJsonNumber(\"humidity\").doubleValue());\r\n            if (json.containsKey(\"soil_moisture\"))\r\n                data.setSoilMoisture(json.getJsonNumber(\"soil_moisture\").doubleValue());\r\n            if (json.containsKey(\"nitrogen\"))\r\n                data.setNitrogen(json.getJsonNumber(\"nitrogen\").doubleValue());\r\n            if (json.containsKey(\"phosphorus\"))\r\n                data.setPhosphorus(json.getJsonNumber(\"phosphorus\").doubleValue());\r\n            if (json.containsKey(\"potassium\"))\r\n                data.setPotassium(json.getJsonNumber(\"potassium\").doubleValue());\r\n            if (json.containsKey(\"pH\"))\r\n                data.setPh(json.getJsonNumber(\"pH\").doubleValue());\r\n            if (json.containsKey(\"rainfall\"))\r\n                data.setRainfall(json.getJsonNumber(\"rainfall\").doubleValue());\r\n\r\n\r\n            saveReading(deviceId, fieldId, data);\r\n\r\n        } catch (Exception e) {\r\n            logger.severe(\"âŒ Error processing sensor/data message: \" + e.getMessage());\r\n            e.printStackTrace();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Save reading in DB\r\n     */\r\n    private void saveReading(String deviceId, String fieldId, SensorData data) {\r\n        try {\r\n            Sensor sensor = null;\r\n            try {\r\n                sensor = sensorRepository.findByDeviceId(deviceId).orElse(null);\r\n            } catch (Exception e) {\r\n                logger.warning(\"âš ï¸ Sensor not found for deviceId: \" + deviceId);\r\n            }\r\n\r\n            SensorReading reading = new SensorReading();\r\n            reading.setId(UUID.randomUUID().toString());\r\n            reading.setSensorId(sensor != null ? sensor.getId() : deviceId);\r\n            reading.setFieldId(fieldId);\r\n            reading.setTimestamp(LocalDateTime.now());\r\n            reading.setData(data);\r\n\r\n            readingRepository.save(reading);\r\n            logger.info(\"âœ… Saved reading for device \" + deviceId +\r\n                    \" | Temp: \" + data.getTemperature() +\r\n                    \"Â°C | Hum: \" + data.getHumidity() +\r\n                    \"% | Moisture: \" + data.getSoilMoisture() +\r\n                    \"% | NPK: \" + data.getNitrogen() + \"/\" +\r\n                    data.getPhosphorus() + \"/\" + data.getPotassium());\r\n\r\n            if (sensor != null) {\r\n                sensor.setLastConnection(LocalDateTime.now());\r\n                sensor.setStatus(\"active\");\r\n                sensorRepository.save(sensor);\r\n            }\r\n\r\n        } catch (Exception e) {\r\n            logger.severe(\"âŒ Failed to save reading: \" + e.getMessage());\r\n            e.printStackTrace();\r\n        }\r\n    }\r\n\r\n    public void publishMessage(String topic, String message) {\r\n        if (mqttClient != null && mqttClient.getState().isConnected()) {\r\n            mqttClient.publishWith()\r\n                    .topic(topic)\r\n                    .payload(message.getBytes(StandardCharsets.UTF_8))\r\n                    .send()\r\n                    .whenComplete((ack, throwable) -> {\r\n                        if (throwable != null) {\r\n                            logger.severe(\"âŒ Failed to publish message: \" + throwable.getMessage());\r\n                        } else {\r\n                            logger.info(\"ðŸ“¤ Published message to topic: \" + topic);\r\n                        }\r\n                    });\r\n        } else {\r\n            logger.warning(\"âš ï¸ MQTT client not connected; message not sent\");\r\n        }\r\n    }\r\n\r\n    @PreDestroy\r\n    public void cleanup() {\r\n        if (mqttClient != null && mqttClient.getState().isConnected()) {\r\n            mqttClient.disconnect();\r\n            logger.info(\"ðŸ›‘ Disconnected from MQTT broker\");\r\n        }\r\n    }\r\n}\r\n",
      "info": {
        "size": 8692,
        "last_modified": "2025-11-11T20:46:11.6302317",
        "mime_type": "text/x-java-source",
        "extension": ".java"
      }
    },
    {
      "path": "resources\\META-INF\\microprofile-config.properties",
      "content": "# JNoSQL MongoDB Configuration\r\njnosql.document=document\r\njnosql.document.database=soilmonitoring_db\r\njnosql.mongodb.url=${JNOSQL_MONGODB_URL}\r\ndocument.provider=org.eclipse.jnosql.databases.mongodb.communication.MongoDBDocumentConfiguration\r\n\r\n# JNoSQL Logging\r\nlogger.org.jnosql=DEBUG\r\n\r\n# MQTT Configuration (HiveMQ Cloud)\r\nmqtt.broker.url=0b1fe1fedc0c453db6ea029b69b32f1c.s1.eu.hivemq.cloud\r\nmqtt.broker.port=8883\r\nmqtt.username=${MQTT_USERNAME}\r\nmqtt.password=${MQTT_PASSWORD}\r\nmqtt.client.id=soil-monitoring-api\r\nmqtt.use.tls=true\r\n\r\n# Application Configuration\r\napp.name=Soil Monitoring API\r\napp.version=1.0",
      "info": {
        "size": 614,
        "last_modified": "2025-11-11T20:46:11.6377409",
        "mime_type": "text/x-java-properties",
        "extension": ".properties"
      }
    },
    {
      "path": "webapp\\WEB-INF\\beans.xml",
      "content": "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<beans xmlns=\"https://jakarta.ee/xml/ns/jakartaee\"\r\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n       xsi:schemaLocation=\"https://jakarta.ee/xml/ns/jakartaee https://jakarta.ee/xml/ns/jakartaee/beans_4_0.xsd\"\r\n       bean-discovery-mode=\"all\">\r\n\r\n</beans>",
      "info": {
        "size": 314,
        "last_modified": "2025-11-11T20:46:11.6422624",
        "mime_type": "application/xml",
        "extension": ".xml"
      }
    },
    {
      "path": "webapp\\WEB-INF\\jboss-web.xml",
      "content": "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<jboss-web xmlns=\"http://www.jboss.com/xml/ns/javaee\" version=\"10.0\">\r\n    <context-root>/</context-root>\r\n    <enable-websockets>true</enable-websockets>\r\n</jboss-web>",
      "info": {
        "size": 208,
        "last_modified": "2025-11-11T20:46:11.6447172",
        "mime_type": "application/xml",
        "extension": ".xml"
      }
    }
  ]
}